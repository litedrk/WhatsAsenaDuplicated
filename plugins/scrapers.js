/* Copyright (C) 2021
Licensed under the  GPL-3.0 License;
you may not use this file except in compliance with the License.
DrkBot - Ian VanH
*/

const DrkBot = require('../events');
const {MessageType,Mimetype} = require('@adiwajshing/baileys');
const translatte = require('translatte');
const config = require('../config');
const LanguageDetect = require('languagedetect');
const lngDetector = new LanguageDetect();
const Heroku = require('heroku-client');
const heroku = new Heroku({
    token: config.HEROKU.API_KEY
});
let baseURI = '/apps/' + config.HEROKU.APP_NAME;

//============================== LYRICS =============================================
const axios = require('axios');
const { requestLyricsFor, requestAuthorFor, requestTitleFor, requestIconFor } = require("solenolyrics");
const solenolyrics= require("solenolyrics");

//============================== TTS ==================================================
const fs = require('fs');
const https = require('https');
const googleTTS = require('google-translate-tts');

//============================== YOUTUBE ==============================================
const ytdl = require('ytdl-core');
const ffmpeg = require('fluent-ffmpeg');
const yts = require( 'yt-search' )
const got = require("got");
const ID3Writer = require('browser-id3-writer');
const SpotifyWebApi = require('spotify-web-api-node');

const spotifyApi = new SpotifyWebApi({
    clientId: 'acc6302297e040aeb6e4ac1fbdfd62c3',
    clientSecret: '0e8439a1280a43aba9a5bc0a16f3f009'
});
//=====================================================================================

const Language = require('../language');
const Lang = Language.getString('scrapers');
const Glang = Language.getString('github');
const Slang = Language.getString('lyrics');

const wiki = require('wikijs').default;
var gis = require('g-i-s');

if (config.WORKTYPE == 'private') {

    DrkBot.addCommand({pattern: 'trt(?: |$)(\\S*) ?(\\S*)', desc: Lang.TRANSLATE_DESC, usage: Lang.TRANSLATE_USAGE, fromMe: true}, (async (message, match) => {

        if (!message.reply_message) {
            return await message.client.sendMessage(message.jid,Lang.NEED_REPLY,MessageType.text);
        }

        ceviri = await translatte(message.reply_message.message, {from: match[1] === '' ? 'auto' : match[1], to: match[2] === '' ? config.LANG : match[2]});
        if ('text' in ceviri) {
            return await message.reply('*‚ñ∂Ô∏è ' + Lang.LANG + ':* ```' + (match[1] === '' ? 'auto' : match[1]) + '```\n'
            + '*‚óÄÔ∏è ' + Lang.FROM + '*: ```' + (match[2] === '' ? config.LANG : match[2]) + '```\n'
            + '*üîé ' + Lang.RESULT + ':* ```' + ceviri.text + '```');
        } else {
            return await message.client.sendMessage(message.jid,Lang.TRANSLATE_ERROR,MessageType.text)
        }
    }));
    var l_dsc = ''
    var alr_on = ''
    var alr_off = ''
    var succ_on = ''
    var succ_off = ''
    if (config.LANG == 'TR') {
        l_dsc = 'Antilink aracƒ±nƒ± etkinle≈ütirir.'
        alr_on = 'Antilink halihazƒ±rda a√ßƒ±k!'
        alr_off = 'Antilink halihazƒ±rda kapalƒ±!'
        succ_on = 'Antilink Ba≈üarƒ±yla A√ßƒ±ldƒ±!'
        succ_off = 'Antilink Ba≈üarƒ±yla Kapatƒ±ldƒ±!'
    }
    if (config.LANG == 'EN') {
        l_dsc = 'Activates the Antilink tool.'
        alr_on = 'Antilink is already open!'
        alr_off = 'Antilink is currently closed!'
        succ_on = 'Antilink Opened Successfully!'
        succ_off = 'Antilink Closed Successfully!'
    }
    if (config.LANG == 'AZ') {
        l_dsc = 'Antilink al…ôtini aktivl…ô≈üdirir.'
        alr_on = 'Antilink hazƒ±rda a√ßƒ±qdƒ±r!'
        alr_off = 'Antilink hazƒ±rda baƒülƒ±dƒ±r!'
        succ_on = 'Antilink Uƒüurla A√ßƒ±ldƒ±!'
        succ_off = 'Antilink Uƒüurla Baƒülandƒ±!'
    }
    if (config.LANG == 'HI') {
        l_dsc = '‡§è‡§Ç‡§ü‡•Ä‡§≤‡§ø‡§Ç‡§ï ‡§ü‡•Ç‡§≤ ‡§ï‡•ã ‡§∏‡§ï‡•ç‡§∞‡§ø‡§Ø ‡§ï‡§∞‡§§‡§æ ‡§π‡•à‡•§'
        alr_on = '‡§è‡§Ç‡§ü‡•Ä‡§≤‡§ø‡§Ç‡§ï ‡§™‡§π‡§≤‡•á ‡§∏‡•á ‡§π‡•Ä ‡§ñ‡•Å‡§≤‡§æ ‡§π‡•à!'
        alr_off = '‡§è‡§Ç‡§ü‡•Ä‡§≤‡§ø‡§Ç‡§ï ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§Æ‡•á‡§Ç ‡§¨‡§Ç‡§¶ ‡§π‡•à!'
        succ_on = '‡§è‡§Ç‡§ü‡•Ä‡§≤‡§ø‡§Ç‡§ï ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§ñ‡•ã‡§≤‡§æ ‡§ó‡§Ø‡§æ!'
        succ_off = '‡§è‡§Ç‡§ü‡•Ä‡§≤‡§ø‡§Ç‡§ï ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§¨‡§Ç‡§¶!'
    }
    if (config.LANG == 'ML') {
        l_dsc = '‡¥Ü‡¥®‡µç‡¥±‡¥ø‡¥≤‡¥ø‡¥ô‡µç‡¥ï‡µç ‡¥â‡¥™‡¥ï‡¥∞‡¥£‡¥Ç ‡¥∏‡¥ú‡µÄ‡¥µ‡¥Æ‡¥æ‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ.'
        alr_on = '‡¥Ü‡¥®‡µç‡¥±‡¥ø‡¥≤‡¥ø‡¥ô‡µç‡¥ï‡µç ‡¥á‡¥§‡¥ø‡¥®‡¥ï‡¥Ç ‡¥§‡µÅ‡¥±‡¥®‡µç‡¥®‡µÅ!'
        alr_off = '‡¥Ü‡¥®‡µç‡¥±‡¥ø‡¥≤‡¥ø‡¥ô‡µç‡¥ï‡µç ‡¥®‡¥ø‡¥≤‡¥µ‡¥ø‡µΩ ‡¥Ö‡¥ü‡¥ö‡µç‡¥ö‡¥ø‡¥∞‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ!'
        succ_on = '‡¥Ü‡¥®‡µç‡¥±‡¥ø‡¥≤‡¥ø‡¥ô‡µç‡¥ï‡µç ‡¥µ‡¥ø‡¥ú‡¥Ø‡¥ï‡¥∞‡¥Æ‡¥æ‡¥Ø‡¥ø ‡¥§‡µÅ‡¥±‡¥®‡µç‡¥®‡µÅ!'
        succ_off = '‡¥Ü‡¥®‡µç‡¥±‡¥ø‡¥≤‡¥ø‡¥ô‡µç‡¥ï‡µç ‡¥µ‡¥ø‡¥ú‡¥Ø‡¥ï‡¥∞‡¥Æ‡¥æ‡¥Ø‡¥ø ‡¥Ö‡¥ü‡¥ö‡µç‡¥ö‡µÅ!'
    }
    if (config.LANG == 'PT') {
        l_dsc = 'Ativa a ferramenta Antilink.'
        alr_on = 'O Antilink j√° est√° aberto!'
        alr_off = 'Antilink est√° fechado no momento!'
        succ_on = 'Antilink aberto com sucesso!'
        succ_off = 'Antilink fechado com sucesso!'
    }
    if (config.LANG == 'RU') {
        l_dsc = '–ê–∫—Ç–∏–≤–∏—Ä—É–µ—Ç –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç Antilink.'
        alr_on = '–ê–Ω—Ç–∏–ª–∏–Ω–∫ —É–∂–µ –æ—Ç–∫—Ä—ã—Ç!'
        alr_off = '–ê–Ω—Ç–∏–ª–∏–Ω–∫ —Å–µ–π—á–∞—Å –∑–∞–∫—Ä—ã—Ç!'
        succ_on = '–ê–Ω—Ç–∏–ª–∏–Ω–∫ —É—Å–ø–µ—à–Ω–æ –æ—Ç–∫—Ä—ã—Ç!'
        succ_off = '–ê–Ω—Ç–∏–ª–∏–Ω–∫ —É—Å–ø–µ—à–Ω–æ –∑–∞–∫—Ä—ã—Ç!'
    }
    if (config.LANG == 'ES') {
        l_dsc = 'Activa la herramienta Antilink.'
        alr_on = '¬°Antilink ya est√° abierto!'
        alr_off = '¬°Antilink est√° cerrado actualmente!'
        succ_on = '¬°Antilink se abri√≥ con √©xito!'
        succ_off = 'Antilink cerrado correctamente!'
    }
    if (config.LANG == 'ID') {
        l_dsc = 'Mengaktifkan alat Antilink.'
        alr_on = 'Antilink sudah terbuka!'
        alr_off = 'Antilink saat ini ditutup!'
        succ_on = 'Antilink Berhasil Dibuka!'
        succ_off = 'Antilink Berhasil Ditutup!'
    }
    DrkBot.addCommand({pattern: 'antilink ?(.*)', fromMe: true, desc: l_dsc, usage: '.antilink on / off' }, (async (message, match) => {
        const anti_status = `${config.ANTƒ∞Lƒ∞NK}`
        if (match[1] == 'on') {
            if (anti_status == 'true') {
                return await message.client.sendMessage(message.jid, '*' + alr_on + '*', MessageType.text)
            }
            else {
                await heroku.patch(baseURI + '/config-vars', { 
                    body: { 
                        ['ANTƒ∞_Lƒ∞NK']: 'true'
                    } 
                });
                await message.client.sendMessage(message.jid, '*' + succ_on + '*', MessageType.text)
            }
        }
        else if (match[1] == 'off') {
            if (anti_status !== 'true') {
                return await message.client.sendMessage(message.jid, '*' + alr_off + '*', MessageType.text)
            }
            else {
                await heroku.patch(baseURI + '/config-vars', { 
                    body: { 
                        ['ANTƒ∞_Lƒ∞NK']: 'false'
                    } 
                });
                await message.client.sendMessage(message.jid, '*' + succ_off + '*', MessageType.text)
            }
        }
    }));
    var auto_dsc = ''
    var alr_on_bio = ''
    var alr_off_bio = ''
    var succ_on_bio = ''
    var succ_off_bio = ''
    if (config.LANG == 'TR') {
        auto_dsc = 'Biyografinize canlƒ± saat ekleyin!'
        alr_on_bio = 'Autobio halihazƒ±rda a√ßƒ±k!'
        alr_off_bio = 'Autobio halihazƒ±rda kapalƒ±!'
        succ_on_bio = 'Autobio Ba≈üarƒ±yla A√ßƒ±ldƒ±!'
        succ_off_bio = 'Autobio Ba≈üarƒ±yla Kapatƒ±ldƒ±!'
    }
    if (config.LANG == 'EN') {
        auto_dsc = 'Add live clock to your bio!'
        alr_on_bio = 'Autobio is already open!'
        alr_off_bio = 'Autobio is currently closed!'
        succ_on_bio = 'Autobio Opened Successfully!'
        succ_off_bio = 'Autobio Closed Successfully!'
    }
    if (config.LANG == 'AZ') {
        auto_dsc = 'Bio-ya canlƒ± saat …ôlav…ô et!'
        alr_on_bio = 'Autobio hazƒ±rda a√ßƒ±qdƒ±r!'
        alr_off_bio = 'Autobio hazƒ±rda baƒülƒ±dƒ±r!'
        succ_on_bio = 'Autobio Uƒüurla A√ßƒ±ldƒ±!'
        succ_off_bio = 'Autobio Uƒüurla Baƒülandƒ±!'
    }
    if (config.LANG == 'HI') {
        auto_dsc = '‡§Ö‡§™‡§®‡•á ‡§¨‡§æ‡§Ø‡•ã ‡§Æ‡•á‡§Ç ‡§≤‡§æ‡§á‡§µ ‡§ò‡§°‡§º‡•Ä ‡§ú‡•ã‡§°‡§º‡•á‡§Ç!'
        alr_on_bio = 'Autobio ‡§™‡§π‡§≤‡•á ‡§∏‡•á ‡§π‡•Ä ‡§ñ‡•Å‡§≤‡§æ ‡§π‡•à!'
        alr_off_bio = 'Autobio ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§Æ‡•á‡§Ç ‡§¨‡§Ç‡§¶ ‡§π‡•à!'
        succ_on_bio = 'Autobio ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§ñ‡•ã‡§≤‡§æ ‡§ó‡§Ø‡§æ!'
        succ_off_bio = 'Autobio ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§¨‡§Ç‡§¶!'
    }
    if (config.LANG == 'ML') {
        auto_dsc = '‡¥®‡¥ø‡¥ô‡µç‡¥ô‡¥≥‡µÅ‡¥ü‡µÜ ‡¥¨‡¥Ø‡µã‡¥Ø‡¥ø‡¥≤‡µá‡¥ï‡µç‡¥ï‡µç ‡¥§‡¥§‡µç‡¥∏‡¥Æ‡¥Ø ‡¥ï‡µç‡¥≤‡µã‡¥ï‡µç‡¥ï‡µç ‡¥ö‡µá‡µº‡¥ï‡µç‡¥ï‡µÅ‡¥ï!'
        alr_on_bio = 'Autobio ‡¥á‡¥§‡¥ø‡¥®‡¥ï‡¥Ç ‡¥§‡µÅ‡¥±‡¥®‡µç‡¥®‡µÅ!'
        alr_off_bio = 'Autobio ‡¥®‡¥ø‡¥≤‡¥µ‡¥ø‡µΩ ‡¥Ö‡¥ü‡¥ö‡µç‡¥ö‡¥ø‡¥∞‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ!'
        succ_on_bio = 'Autobio ‡¥µ‡¥ø‡¥ú‡¥Ø‡¥ï‡¥∞‡¥Æ‡¥æ‡¥Ø‡¥ø ‡¥§‡µÅ‡¥±‡¥®‡µç‡¥®‡µÅ!'
        succ_off_bio = 'Autobio ‡¥µ‡¥ø‡¥ú‡¥Ø‡¥ï‡¥∞‡¥Æ‡¥æ‡¥Ø‡¥ø ‡¥Ö‡¥ü‡¥ö‡µç‡¥ö‡µÅ!'
    }
    if (config.LANG == 'PT') {
        auto_dsc = 'Adicione um rel√≥gio ao vivo √† sua biografia!'
        alr_on_bio = 'O Autobio j√° est√° aberto!'
        alr_off_bio = 'Autobio est√° fechado no momento!'
        succ_on_bio = 'Autobio aberto com sucesso!'
        succ_off_bio = 'Autobio fechado com sucesso!'
    }
    if (config.LANG == 'RU') {
        auto_dsc = '–î–æ–±–∞–≤—å—Ç–µ –∂–∏–≤—ã–µ —á–∞—Å—ã –≤ —Å–≤–æ—é –±–∏–æ–≥—Ä–∞—Ñ–∏—é!'
        alr_on_bio = 'Autobio —É–∂–µ –æ—Ç–∫—Ä—ã—Ç!'
        alr_off_bio = 'Autobio —Å–µ–π—á–∞—Å –∑–∞–∫—Ä—ã—Ç!'
        succ_on_bio = 'Autobio —É—Å–ø–µ—à–Ω–æ –æ—Ç–∫—Ä—ã—Ç!'
        succ_off_bio = 'Autobio —É—Å–ø–µ—à–Ω–æ –∑–∞–∫—Ä—ã—Ç!'
    }
    if (config.LANG == 'ES') {
        auto_dsc = '¬°Agrega un reloj en vivo a tu biograf√≠a!'
        alr_on_bio = '¬°Autobio ya est√° abierto!'
        alr_off_bio = '¬°Autobio est√° cerrado actualmente!'
        succ_on_bio = '¬°Autobio se abri√≥ con √©xito!'
        succ_off_bio = 'Autobio cerrado correctamente!'
    }
    if (config.LANG == 'ID') {
        auto_dsc = 'Tambahkan jam langsung ke bio Anda!'
        alr_on_bio = 'Autobio sudah terbuka!'
        alr_off_bio = 'Autobio saat ini ditutup!'
        succ_on_bio = 'Autobio Berhasil Dibuka!'
        succ_off_bio = 'Autobio Berhasil Ditutup!'
    }
    DrkBot.addCommand({pattern: 'autobio ?(.*)', fromMe: true, desc: auto_dsc, usage: '.autobio on / off' }, (async (message, match) => {
        const bio_status = `${config.AUTOBƒ∞O}`
        if (match[1] == 'on') {
            if (bio_status == 'true') {
                return await message.client.sendMessage(message.jid, '*' + alr_on_bio + '*', MessageType.text)
            }
            else {
                await heroku.patch(baseURI + '/config-vars', { 
                    body: { 
                        ['AUTO_Bƒ∞O']: 'true'
                    } 
                });
                await message.client.sendMessage(message.jid, '*' + succ_on_bio + '*', MessageType.text)
            }
        }
        else if (match[1] == 'off') {
            if (bio_status !== 'true') {
                return await message.client.sendMessage(message.jid, '*' + alr_off_bio + '*', MessageType.text)
            }
            else {
                await heroku.patch(baseURI + '/config-vars', { 
                    body: { 
                        ['AUTO_Bƒ∞O']: 'false'
                    } 
                });
                await message.client.sendMessage(message.jid, '*' + succ_off_bio + '*', MessageType.text)
            }
        }
    }));

    DrkBot.addCommand({pattern: 'tts (.*)', fromMe: true, desc: Lang.TTS_DESC}, (async (message, match) => {

        if(match[1] === undefined || match[1] == "")
            return;
    
        let 
            LANG = config.LANG.toLowerCase(),
            ttsMessage = match[1],
            SPEED = 1.0

        if(langMatch = match[1].match("\\{([a-z]{2})\\}")) {
            LANG = langMatch[1]
            ttsMessage = ttsMessage.replace(langMatch[0], "")
        } 
        if(speedMatch = match[1].match("\\{([0].[0-9]+)\\}")) {
            SPEED = parseFloat(speedMatch[1])
            ttsMessage = ttsMessage.replace(speedMatch[0], "")
        }

        var buffer = await googleTTS.synthesize({
            text: ttsMessage,
            voice: LANG
        });
        await message.client.sendMessage(message.jid,buffer, MessageType.audio, {mimetype: Mimetype.mp4Audio, ptt: true});
    }));

    DrkBot.addCommand({pattern: 'song ?(.*)', fromMe: true, desc: Lang.SONG_DESC}, (async (message, match) => { 

        if (match[1] === '') return await message.client.sendMessage(message.jid,Lang.NEED_TEXT_SONG,MessageType.text);    
        let arama = await yts(match[1]);
        arama = arama.all;
        if(arama.length < 1) return await message.client.sendMessage(message.jid,Lang.NO_RESULT,MessageType.text);
        var reply = await message.client.sendMessage(message.jid,Lang.DOWNLOADING_SONG,MessageType.text);

        let title = arama[0].title.replace(' ', '+');
        let stream = ytdl(arama[0].videoId, {
            quality: 'highestaudio',
        });
    
        got.stream(arama[0].image).pipe(fs.createWriteStream(title + '.jpg'));
        ffmpeg(stream)
            .audioBitrate(320)
            .save('./' + title + '.mp3')
            .on('end', async () => {
                const writer = new ID3Writer(fs.readFileSync('./' + title + '.mp3'));
                writer.setFrame('TIT2', arama[0].title)
                    .setFrame('TPE1', [arama[0].author.name])
                    .setFrame('APIC', {
                        type: 3,
                        data: fs.readFileSync(title + '.jpg'),
                        description: arama[0].description
                    });
                writer.addTag();

                reply = await message.client.sendMessage(message.jid,Lang.UPLOADING_SONG,MessageType.text);
                await message.client.sendMessage(message.jid,Buffer.from(writer.arrayBuffer), MessageType.audio, {mimetype: Mimetype.mp4Audio, ptt: false});
            });
    }));

    DrkBot.addCommand({pattern: 'video ?(.*)', fromMe: true, desc: Lang.VIDEO_DESC}, (async (message, match) => { 

        if (match[1] === '') return await message.client.sendMessage(message.jid,Lang.NEED_VIDEO,MessageType.text);    
    
        var VID = '';
        try {
            if (match[1].includes('watch')) {
                var tsts = match[1].replace('watch?v=', '')
                var alal = tsts.split('/')[3]
                VID = alal
            } else {     
                VID = match[1].split('/')[3]
            }
        } catch {
            return await message.client.sendMessage(message.jid,Lang.NO_RESULT,MessageType.text);
        }
        var reply = await message.client.sendMessage(message.jid,Lang.DOWNLOADING_VIDEO,MessageType.text);

        var yt = ytdl(VID, {filter: format => format.container === 'mp4' && ['720p', '480p', '360p', '240p', '144p'].map(() => true)});
        yt.pipe(fs.createWriteStream('./' + VID + '.mp4'));

        yt.on('end', async () => {
            reply = await message.client.sendMessage(message.jid,Lang.UPLOADING_VIDEO,MessageType.text);
            await message.client.sendMessage(message.jid,fs.readFileSync('./' + VID + '.mp4'), MessageType.video, {mimetype: Mimetype.mp4});
        });
    }));

    DrkBot.addCommand({pattern: 'yt ?(.*)', fromMe: true, desc: Lang.YT_DESC}, (async (message, match) => { 

        if (match[1] === '') return await message.client.sendMessage(message.jid,Lang.NEED_WORDS,MessageType.text);    
        var reply = await message.client.sendMessage(message.jid,Lang.GETTING_VIDEOS,MessageType.text);

        try {
            var arama = await yts(match[1]);
        } catch {
            return await message.client.sendMessage(message.jid,Lang.NOT_FOUND,MessageType.text);
        }
    
        var mesaj = '';
        arama.all.map((video) => {
            mesaj += '*' + video.title + '* - ' + video.url + '\n'
        });

        await message.client.sendMessage(message.jid,mesaj,MessageType.text);
        await reply.delete();
    }));

    DrkBot.addCommand({pattern: 'wiki ?(.*)', fromMe: true, desc: Lang.WIKI_DESC}, (async (message, match) => { 

        if (match[1] === '') return await message.client.sendMessage(message.jid,Lang.NEED_WORDS,MessageType.text);    
        var reply = await message.client.sendMessage(message.jid,Lang.SEARCHING,MessageType.text);

        var arama = await wiki({ apiUrl: 'https://' + config.LANG + '.wikipedia.org/w/api.php' })
            .page(match[1]);

        var info = await arama.rawContent();
        await message.client.sendMessage(message.jid, info, MessageType.text);
        await reply.delete();
    }));

    DrkBot.addCommand({pattern: 'img ?(.*)', fromMe: true, desc: Lang.IMG_DESC}, (async (message, match) => { 

        if (match[1] === '') return await message.client.sendMessage(message.jid,Lang.NEED_WORDS,MessageType.text);
        gis(match[1], async (error, result) => {
            for (var i = 0; i < (result.length < 5 ? result.length : 5); i++) {
                var get = got(result[i].url, {https: {rejectUnauthorized: false}});
                var stream = get.buffer();
                
                stream.then(async (image) => {
                    await message.client.sendMessage(message.jid,image, MessageType.image);
                });
            }

            message.reply(Lang.IMG.format((result.length < 5 ? result.length : 5), match[1]));
        });
    }));
    /*
    DrkBot.addCommand({ pattern: 'github ?(.*)', fromMe: true, desc: Glang.Gƒ∞THUB_DESC }, async (message, match) => {

        const userName = match[1]
 
        if (userName === '') return await message.client.sendMessage(message.jid, Glang.REPLY, MessageType.text)

        await axios
          .get(`https://videfikri.com/api/github/?username=${userName}`)
          .then(async (response) => {

            const {
              hireable,
              company,
              profile_pic,
              username,
              fullname, 
              blog, 
              location,
              email,
              public_repository,
              biografi,
              following,
              followers,
              public_gists,
              profile_url,
              last_updated,
              joined_on,
            } = response.data.result

            const githubscrap = await axios.get(profile_pic, 
              {responseType: 'arraybuffer',
            })

            const msg = `*${Glang.USERNAME}* ${username} \n*${Glang.NAME}* ${fullname} \n*${Glang.FOLLOWERS}* ${followers} \n*${Glang.FOLLOWƒ∞NG}* ${following} \n*${Glang.Bƒ∞O}* ${biografi} \n*${Glang.REPO}* ${public_repository} \n*${Glang.Gƒ∞ST}* ${public_gists} \n*${Glang.LOCATƒ∞ON}* ${location} \n*${Glang.MAƒ∞L}* ${email} \n*${Glang.BLOG}* ${blog} \n*${Glang.COMPANY}* ${company} \n*${Glang.Hƒ∞RE}* ${hireable === "true" ? Glang.Hƒ∞RE_TRUE : Glang.Hƒ∞RE_FALSE} \n*${Glang.JOƒ∞N}* ${joined_on} \n*${Glang.UPDATE}* ${last_updated} \n*${Glang.URL}* ${profile_url}`

            await message.sendMessage(Buffer.from(githubscrap.data), MessageType.image, { 
              caption: msg,
            })
          })
          .catch(
            async (err) => await message.client.sendMessage(message.jid, Glang.NOT, MessageType.text),
          )
      },
    )
    */
    DrkBot.addCommand({pattern: 'lyric ?(.*)', fromMe: true, desc: Slang.LY_DESC }, (async (message, match) => { 

        if (match[1] === '') return await message.client.sendMessage(message.jid, Slang.NEED, MessageType.text);

        var aut = await solenolyrics.requestLyricsFor(`${match[1]}`); 
        var son = await solenolyrics.requestAuthorFor(`${match[1]}`);
        var cov = await solenolyrics.requestIconFor(`${match[1]}`);
        var tit = await solenolyrics.requestTitleFor(`${match[1]}`);

        var buffer = await axios.get(cov, {responseType: 'arraybuffer'});

        await message.client.sendMessage(message.jid, Buffer.from(buffer.data),  MessageType.image, {caption: `*${Slang.ARAT}* ` + '```' + `${match[1]}` + '```' + `\n*${Slang.BUL}* ` + '```' + tit + '```' + `\n*${Slang.AUT}* ` + '```' + son + '```' + `\n*${Slang.SLY}*\n\n` + aut });

    }));
}
else if (config.WORKTYPE == 'public') {

    DrkBot.addCommand({pattern: 'trt(?: |$)(\\S*) ?(\\S*)', desc: Lang.TRANSLATE_DESC, usage: Lang.TRANSLATE_USAGE, fromMe: false}, (async (message, match) => {

        if (!message.reply_message) {
            return await message.client.sendMessage(message.jid,Lang.NEED_REPLY,MessageType.text);
        }

        ceviri = await translatte(message.reply_message.message, {from: match[1] === '' ? 'auto' : match[1], to: match[2] === '' ? config.LANG : match[2]});
        if ('text' in ceviri) {
            return await message.reply('*‚ñ∂Ô∏è ' + Lang.LANG + ':* ```' + (match[1] === '' ? 'auto' : match[1]) + '```\n'
            + '*‚óÄÔ∏è ' + Lang.FROM + '*: ```' + (match[2] === '' ? config.LANG : match[2]) + '```\n'
            + '*üîé ' + Lang.RESULT + ':* ```' + ceviri.text + '```');
        } else {
            return await message.client.sendMessage(message.jid,Lang.TRANSLATE_ERROR,MessageType.text)
        }
    }));
    var l_dsc = ''
    var alr_on = ''
    var alr_off = ''
    var succ_on = ''
    var succ_off = ''
    if (config.LANG == 'TR') {
        l_dsc = 'Antilink aracƒ±nƒ± etkinle≈ütirir.'
        alr_on = 'Antilink halihazƒ±rda a√ßƒ±k!'
        alr_off = 'Antilink halihazƒ±rda kapalƒ±!'
        succ_on = 'Antilink Ba≈üarƒ±yla A√ßƒ±ldƒ±!'
        succ_off = 'Antilink Ba≈üarƒ±yla Kapatƒ±ldƒ±!'
    }
    if (config.LANG == 'EN') {
        l_dsc = 'Activates the Antilink tool.'
        alr_on = 'Antilink is already open!'
        alr_off = 'Antilink is currently closed!'
        succ_on = 'Antilink Opened Successfully!'
        succ_off = 'Antilink Closed Successfully!'
    }
    if (config.LANG == 'AZ') {
        l_dsc = 'Antilink al…ôtini aktivl…ô≈üdirir.'
        alr_on = 'Antilink hazƒ±rda a√ßƒ±qdƒ±r!'
        alr_off = 'Antilink hazƒ±rda baƒülƒ±dƒ±r!'
        succ_on = 'Antilink Uƒüurla A√ßƒ±ldƒ±!'
        succ_off = 'Antilink Uƒüurla Baƒülandƒ±!'
    }
    if (config.LANG == 'HI') {
        l_dsc = '‡§è‡§Ç‡§ü‡•Ä‡§≤‡§ø‡§Ç‡§ï ‡§ü‡•Ç‡§≤ ‡§ï‡•ã ‡§∏‡§ï‡•ç‡§∞‡§ø‡§Ø ‡§ï‡§∞‡§§‡§æ ‡§π‡•à‡•§'
        alr_on = '‡§è‡§Ç‡§ü‡•Ä‡§≤‡§ø‡§Ç‡§ï ‡§™‡§π‡§≤‡•á ‡§∏‡•á ‡§π‡•Ä ‡§ñ‡•Å‡§≤‡§æ ‡§π‡•à!'
        alr_off = '‡§è‡§Ç‡§ü‡•Ä‡§≤‡§ø‡§Ç‡§ï ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§Æ‡•á‡§Ç ‡§¨‡§Ç‡§¶ ‡§π‡•à!'
        succ_on = '‡§è‡§Ç‡§ü‡•Ä‡§≤‡§ø‡§Ç‡§ï ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§ñ‡•ã‡§≤‡§æ ‡§ó‡§Ø‡§æ!'
        succ_off = '‡§è‡§Ç‡§ü‡•Ä‡§≤‡§ø‡§Ç‡§ï ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§¨‡§Ç‡§¶!'
    }
    if (config.LANG == 'ML') {
        l_dsc = '‡¥Ü‡¥®‡µç‡¥±‡¥ø‡¥≤‡¥ø‡¥ô‡µç‡¥ï‡µç ‡¥â‡¥™‡¥ï‡¥∞‡¥£‡¥Ç ‡¥∏‡¥ú‡µÄ‡¥µ‡¥Æ‡¥æ‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ.'
        alr_on = '‡¥Ü‡¥®‡µç‡¥±‡¥ø‡¥≤‡¥ø‡¥ô‡µç‡¥ï‡µç ‡¥á‡¥§‡¥ø‡¥®‡¥ï‡¥Ç ‡¥§‡µÅ‡¥±‡¥®‡µç‡¥®‡µÅ!'
        alr_off = '‡¥Ü‡¥®‡µç‡¥±‡¥ø‡¥≤‡¥ø‡¥ô‡µç‡¥ï‡µç ‡¥®‡¥ø‡¥≤‡¥µ‡¥ø‡µΩ ‡¥Ö‡¥ü‡¥ö‡µç‡¥ö‡¥ø‡¥∞‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ!'
        succ_on = '‡¥Ü‡¥®‡µç‡¥±‡¥ø‡¥≤‡¥ø‡¥ô‡µç‡¥ï‡µç ‡¥µ‡¥ø‡¥ú‡¥Ø‡¥ï‡¥∞‡¥Æ‡¥æ‡¥Ø‡¥ø ‡¥§‡µÅ‡¥±‡¥®‡µç‡¥®‡µÅ!'
        succ_off = '‡¥Ü‡¥®‡µç‡¥±‡¥ø‡¥≤‡¥ø‡¥ô‡µç‡¥ï‡µç ‡¥µ‡¥ø‡¥ú‡¥Ø‡¥ï‡¥∞‡¥Æ‡¥æ‡¥Ø‡¥ø ‡¥Ö‡¥ü‡¥ö‡µç‡¥ö‡µÅ!'
    }
    if (config.LANG == 'PT') {
        l_dsc = 'Ativa a ferramenta Antilink.'
        alr_on = 'O Antilink j√° est√° aberto!'
        alr_off = 'Antilink est√° fechado no momento!'
        succ_on = 'Antilink aberto com sucesso!'
        succ_off = 'Antilink fechado com sucesso!'
    }
    if (config.LANG == 'RU') {
        l_dsc = '–ê–∫—Ç–∏–≤–∏—Ä—É–µ—Ç –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç Antilink.'
        alr_on = '–ê–Ω—Ç–∏–ª–∏–Ω–∫ —É–∂–µ –æ—Ç–∫—Ä—ã—Ç!'
        alr_off = '–ê–Ω—Ç–∏–ª–∏–Ω–∫ —Å–µ–π—á–∞—Å –∑–∞–∫—Ä—ã—Ç!'
        succ_on = '–ê–Ω—Ç–∏–ª–∏–Ω–∫ —É—Å–ø–µ—à–Ω–æ –æ—Ç–∫—Ä—ã—Ç!'
        succ_off = '–ê–Ω—Ç–∏–ª–∏–Ω–∫ —É—Å–ø–µ—à–Ω–æ –∑–∞–∫—Ä—ã—Ç!'
    }
    if (config.LANG == 'ES') {
        l_dsc = 'Activa la herramienta Antilink.'
        alr_on = '¬°Antilink ya est√° abierto!'
        alr_off = '¬°Antilink est√° cerrado actualmente!'
        succ_on = '¬°Antilink se abri√≥ con √©xito!'
        succ_off = 'Antilink cerrado correctamente!'
    }
    if (config.LANG == 'ID') {
        l_dsc = 'Mengaktifkan alat Antilink.'
        alr_on = 'Antilink sudah terbuka!'
        alr_off = 'Antilink saat ini ditutup!'
        succ_on = 'Antilink Berhasil Dibuka!'
        succ_off = 'Antilink Berhasil Ditutup!'
    }
    DrkBot.addCommand({pattern: 'antilink ?(.*)', fromMe: true, desc: l_dsc, usage: '.antilink on / off' }, (async (message, match) => {
        const anti_status = `${config.ANTƒ∞Lƒ∞NK}`
        if (match[1] == 'on') {
            if (anti_status == 'true') {
                return await message.client.sendMessage(message.jid, '*' + alr_on + '*', MessageType.text)
            }
            else {
                await heroku.patch(baseURI + '/config-vars', { 
                    body: { 
                        ['ANTƒ∞_Lƒ∞NK']: 'true'
                    } 
                });
                await message.client.sendMessage(message.jid, '*' + succ_on + '*', MessageType.text)
            }
        }
        else if (match[1] == 'off') {
            if (anti_status !== 'true') {
                return await message.client.sendMessage(message.jid, '*' + alr_off + '*', MessageType.text)
            }
            else {
                await heroku.patch(baseURI + '/config-vars', { 
                    body: { 
                        ['ANTƒ∞_Lƒ∞NK']: 'false'
                    } 
                });
                await message.client.sendMessage(message.jid, '*' + succ_off + '*', MessageType.text)
            }
        }
    }));

    DrkBot.addCommand({pattern: 'tts (.*)', fromMe: false, desc: Lang.TTS_DESC}, (async (message, match) => {

        if(match[1] === undefined || match[1] == "")
            return;
    
        let 
            LANG = config.LANG.toLowerCase(),
            ttsMessage = match[1],
            SPEED = 1.0

        if(langMatch = match[1].match("\\{([a-z]{2})\\}")) {
            LANG = langMatch[1]
            ttsMessage = ttsMessage.replace(langMatch[0], "")
        } 
        if(speedMatch = match[1].match("\\{([0].[0-9]+)\\}")) {
            SPEED = parseFloat(speedMatch[1])
            ttsMessage = ttsMessage.replace(speedMatch[0], "")
        }

        var buffer = await googleTTS.synthesize({
            text: ttsMessage,
            voice: LANG
        });
        await message.client.sendMessage(message.jid,buffer, MessageType.audio, {mimetype: Mimetype.mp4Audio, ptt: true});
    }));

    DrkBot.addCommand({pattern: 'song ?(.*)', fromMe: false, desc: Lang.SONG_DESC}, (async (message, match) => { 

        if (match[1] === '') return await message.client.sendMessage(message.jid,Lang.NEED_TEXT_SONG,MessageType.text);    
        let arama = await yts(match[1]);
        arama = arama.all;
        if(arama.length < 1) return await message.client.sendMessage(message.jid,Lang.NO_RESULT,MessageType.text);
        var reply = await message.client.sendMessage(message.jid,Lang.DOWNLOADING_SONG,MessageType.text);

        let title = arama[0].title.replace(' ', '+');
        let stream = ytdl(arama[0].videoId, {
            quality: 'highestaudio',
        });
    
        got.stream(arama[0].image).pipe(fs.createWriteStream(title + '.jpg'));
        ffmpeg(stream)
            .audioBitrate(320)
            .save('./' + title + '.mp3')
            .on('end', async () => {
                const writer = new ID3Writer(fs.readFileSync('./' + title + '.mp3'));
                writer.setFrame('TIT2', arama[0].title)
                    .setFrame('TPE1', [arama[0].author.name])
                    .setFrame('APIC', {
                        type: 3,
                        data: fs.readFileSync(title + '.jpg'),
                        description: arama[0].description
                    });
                writer.addTag();

                reply = await message.client.sendMessage(message.jid,Lang.UPLOADING_SONG,MessageType.text);
                await message.client.sendMessage(message.jid,Buffer.from(writer.arrayBuffer), MessageType.audio, {mimetype: Mimetype.mp4Audio, ptt: false});
            });
    }));

    DrkBot.addCommand({pattern: 'video ?(.*)', fromMe: false, desc: Lang.VIDEO_DESC}, (async (message, match) => { 

        if (match[1] === '') return await message.client.sendMessage(message.jid,Lang.NEED_VIDEO,MessageType.text);    
    
        var VID = '';
        try {
            if (match[1].includes('watch')) {
                var tsts = match[1].replace('watch?v=', '')
                var alal = tsts.split('/')[3]
                VID = alal
            } else {     
                VID = match[1].split('/')[3]
            }
        } catch {
            return await message.client.sendMessage(message.jid,Lang.NO_RESULT,MessageType.text);
        }
        var reply = await message.client.sendMessage(message.jid,Lang.DOWNLOADING_VIDEO,MessageType.text);

        var yt = ytdl(VID, {filter: format => format.container === 'mp4' && ['720p', '480p', '360p', '240p', '144p'].map(() => true)});
        yt.pipe(fs.createWriteStream('./' + VID + '.mp4'));

        yt.on('end', async () => {
            reply = await message.client.sendMessage(message.jid,Lang.UPLOADING_VIDEO,MessageType.text);
            await message.client.sendMessage(message.jid,fs.readFileSync('./' + VID + '.mp4'), MessageType.video, {mimetype: Mimetype.mp4});
        });
    }));

    DrkBot.addCommand({pattern: 'yt ?(.*)', fromMe: false, desc: Lang.YT_DESC}, (async (message, match) => { 

        if (match[1] === '') return await message.client.sendMessage(message.jid,Lang.NEED_WORDS,MessageType.text);    
        var reply = await message.client.sendMessage(message.jid,Lang.GETTING_VIDEOS,MessageType.text);

        try {
            var arama = await yts(match[1]);
        } catch {
            return await message.client.sendMessage(message.jid,Lang.NOT_FOUND,MessageType.text);
        }
    
        var mesaj = '';
        arama.all.map((video) => {
            mesaj += '*' + video.title + '* - ' + video.url + '\n'
        });

        await message.client.sendMessage(message.jid,mesaj,MessageType.text);
        await reply.delete();
    }));

    DrkBot.addCommand({pattern: 'wiki ?(.*)', fromMe: false, desc: Lang.WIKI_DESC}, (async (message, match) => { 

        if (match[1] === '') return await message.client.sendMessage(message.jid,Lang.NEED_WORDS,MessageType.text);    
        var reply = await message.client.sendMessage(message.jid,Lang.SEARCHING,MessageType.text);

        var arama = await wiki({ apiUrl: 'https://' + config.LANG + '.wikipedia.org/w/api.php' })
            .page(match[1]);

        var info = await arama.rawContent();
        await message.client.sendMessage(message.jid, info, MessageType.text);
        await reply.delete();
    }));

    DrkBot.addCommand({pattern: 'img ?(.*)', fromMe: false, desc: Lang.IMG_DESC}, (async (message, match) => { 

        if (match[1] === '') return await message.client.sendMessage(message.jid,Lang.NEED_WORDS,MessageType.text);
        gis(match[1], async (error, result) => {
            for (var i = 0; i < (result.length < 5 ? result.length : 5); i++) {
                var get = got(result[i].url, {https: {rejectUnauthorized: false}});
                var stream = get.buffer();
                
                stream.then(async (image) => {
                    await message.client.sendMessage(message.jid,image, MessageType.image);
                });
            }

            message.reply(Lang.IMG.format((result.length < 5 ? result.length : 5), match[1]));
        });
    }));

    DrkBot.addCommand({pattern: 'lyric ?(.*)', fromMe: false, desc: Slang.LY_DESC }, (async (message, match) => { 

        if (match[1] === '') return await message.client.sendMessage(message.jid, Slang.NEED, MessageType.text);

        var aut = await solenolyrics.requestLyricsFor(`${match[1]}`); 
        var son = await solenolyrics.requestAuthorFor(`${match[1]}`);
        var cov = await solenolyrics.requestIconFor(`${match[1]}`);
        var tit = await solenolyrics.requestTitleFor(`${match[1]}`);

        var buffer = await axios.get(cov, {responseType: 'arraybuffer'});

        await message.client.sendMessage(message.jid, Buffer.from(buffer.data),  MessageType.image, {caption: `*${Slang.ARAT}* ` + '```' + `${match[1]}` + '```' + `\n*${Slang.BUL}* ` + '```' + tit + '```' + `\n*${Slang.AUT}* ` + '```' + son + '```' + `\n*${Slang.SLY}*\n\n` + aut });

    }));

// duplicado =========================================================================
    DrkBot.addCommand({pattern: 'trt(?: |$)(\\S*) ?(\\S*)', desc: Lang.TRANSLATE_DESC, usage: Lang.TRANSLATE_USAGE, fromMe: true}, (async (message, match) => {

        if (!message.reply_message) {
            return await message.client.sendMessage(message.jid,Lang.NEED_REPLY,MessageType.text);
        }

        ceviri = await translatte(message.reply_message.message, {from: match[1] === '' ? 'auto' : match[1], to: match[2] === '' ? config.LANG : match[2]});
        if ('text' in ceviri) {
            return await message.reply('*‚ñ∂Ô∏è ' + Lang.LANG + ':* ```' + (match[1] === '' ? 'auto' : match[1]) + '```\n'
            + '*‚óÄÔ∏è ' + Lang.FROM + '*: ```' + (match[2] === '' ? config.LANG : match[2]) + '```\n'
            + '*üîé ' + Lang.RESULT + ':* ```' + ceviri.text + '```');
        } else {
            return await message.client.sendMessage(message.jid,Lang.TRANSLATE_ERROR,MessageType.text)
        }
    }));

    var auto_dsc = ''
    var alr_on_bio = ''
    var alr_off_bio = ''
    var succ_on_bio = ''
    var succ_off_bio = ''
    if (config.LANG == 'TR') {
        auto_dsc = 'Biyografinize canlƒ± saat ekleyin!'
        alr_on_bio = 'Autobio halihazƒ±rda a√ßƒ±k!'
        alr_off_bio = 'Autobio halihazƒ±rda kapalƒ±!'
        succ_on_bio = 'Autobio Ba≈üarƒ±yla A√ßƒ±ldƒ±!'
        succ_off_bio = 'Autobio Ba≈üarƒ±yla Kapatƒ±ldƒ±!'
    }
    if (config.LANG == 'EN') {
        auto_dsc = 'Add live clock to your bio!'
        alr_on_bio = 'Autobio is already open!'
        alr_off_bio = 'Autobio is currently closed!'
        succ_on_bio = 'Autobio Opened Successfully!'
        succ_off_bio = 'Autobio Closed Successfully!'
    }
    if (config.LANG == 'AZ') {
        auto_dsc = 'Bio-ya canlƒ± saat …ôlav…ô et!'
        alr_on_bio = 'Autobio hazƒ±rda a√ßƒ±qdƒ±r!'
        alr_off_bio = 'Autobio hazƒ±rda baƒülƒ±dƒ±r!'
        succ_on_bio = 'Autobio Uƒüurla A√ßƒ±ldƒ±!'
        succ_off_bio = 'Autobio Uƒüurla Baƒülandƒ±!'
    }
    if (config.LANG == 'HI') {
        auto_dsc = '‡§Ö‡§™‡§®‡•á ‡§¨‡§æ‡§Ø‡•ã ‡§Æ‡•á‡§Ç ‡§≤‡§æ‡§á‡§µ ‡§ò‡§°‡§º‡•Ä ‡§ú‡•ã‡§°‡§º‡•á‡§Ç!'
        alr_on_bio = 'Autobio ‡§™‡§π‡§≤‡•á ‡§∏‡•á ‡§π‡•Ä ‡§ñ‡•Å‡§≤‡§æ ‡§π‡•à!'
        alr_off_bio = 'Autobio ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§Æ‡•á‡§Ç ‡§¨‡§Ç‡§¶ ‡§π‡•à!'
        succ_on_bio = 'Autobio ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§ñ‡•ã‡§≤‡§æ ‡§ó‡§Ø‡§æ!'
        succ_off_bio = 'Autobio ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§¨‡§Ç‡§¶!'
    }
    if (config.LANG == 'ML') {
        auto_dsc = '‡¥®‡¥ø‡¥ô‡µç‡¥ô‡¥≥‡µÅ‡¥ü‡µÜ ‡¥¨‡¥Ø‡µã‡¥Ø‡¥ø‡¥≤‡µá‡¥ï‡µç‡¥ï‡µç ‡¥§‡¥§‡µç‡¥∏‡¥Æ‡¥Ø ‡¥ï‡µç‡¥≤‡µã‡¥ï‡µç‡¥ï‡µç ‡¥ö‡µá‡µº‡¥ï‡µç‡¥ï‡µÅ‡¥ï!'
        alr_on_bio = 'Autobio ‡¥á‡¥§‡¥ø‡¥®‡¥ï‡¥Ç ‡¥§‡µÅ‡¥±‡¥®‡µç‡¥®‡µÅ!'
        alr_off_bio = 'Autobio ‡¥®‡¥ø‡¥≤‡¥µ‡¥ø‡µΩ ‡¥Ö‡¥ü‡¥ö‡µç‡¥ö‡¥ø‡¥∞‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ!'
        succ_on_bio = 'Autobio ‡¥µ‡¥ø‡¥ú‡¥Ø‡¥ï‡¥∞‡¥Æ‡¥æ‡¥Ø‡¥ø ‡¥§‡µÅ‡¥±‡¥®‡µç‡¥®‡µÅ!'
        succ_off_bio = 'Autobio ‡¥µ‡¥ø‡¥ú‡¥Ø‡¥ï‡¥∞‡¥Æ‡¥æ‡¥Ø‡¥ø ‡¥Ö‡¥ü‡¥ö‡µç‡¥ö‡µÅ!'
    }
    if (config.LANG == 'PT') {
        auto_dsc = 'Adicione um rel√≥gio ao vivo √† sua biografia!'
        alr_on_bio = 'O Autobio j√° est√° aberto!'
        alr_off_bio = 'Autobio est√° fechado no momento!'
        succ_on_bio = 'Autobio aberto com sucesso!'
        succ_off_bio = 'Autobio fechado com sucesso!'
    }
    if (config.LANG == 'RU') {
        auto_dsc = '–î–æ–±–∞–≤—å—Ç–µ –∂–∏–≤—ã–µ —á–∞—Å—ã –≤ —Å–≤–æ—é –±–∏–æ–≥—Ä–∞—Ñ–∏—é!'
        alr_on_bio = 'Autobio —É–∂–µ –æ—Ç–∫—Ä—ã—Ç!'
        alr_off_bio = 'Autobio —Å–µ–π—á–∞—Å –∑–∞–∫—Ä—ã—Ç!'
        succ_on_bio = 'Autobio —É—Å–ø–µ—à–Ω–æ –æ—Ç–∫—Ä—ã—Ç!'
        succ_off_bio = 'Autobio —É—Å–ø–µ—à–Ω–æ –∑–∞–∫—Ä—ã—Ç!'
    }
    if (config.LANG == 'ES') {
        auto_dsc = '¬°Agrega un reloj en vivo a tu biograf√≠a!'
        alr_on_bio = '¬°Autobio ya est√° abierto!'
        alr_off_bio = '¬°Autobio est√° cerrado actualmente!'
        succ_on_bio = '¬°Autobio se abri√≥ con √©xito!'
        succ_off_bio = 'Autobio cerrado correctamente!'
    }
    if (config.LANG == 'ID') {
        auto_dsc = 'Tambahkan jam langsung ke bio Anda!'
        alr_on_bio = 'Autobio sudah terbuka!'
        alr_off_bio = 'Autobio saat ini ditutup!'
        succ_on_bio = 'Autobio Berhasil Dibuka!'
        succ_off_bio = 'Autobio Berhasil Ditutup!'
    }
    DrkBot.addCommand({pattern: 'autobio ?(.*)', fromMe: true, desc: auto_dsc, usage: '.autobio on / off' }, (async (message, match) => {
        const bio_status = `${config.AUTOBƒ∞O}`
        if (match[1] == 'on') {
            if (bio_status == 'true') {
                return await message.client.sendMessage(message.jid, '*' + alr_on_bio + '*', MessageType.text)
            }
            else {
                await heroku.patch(baseURI + '/config-vars', { 
                    body: { 
                        ['AUTO_Bƒ∞O']: 'true'
                    } 
                });
                await message.client.sendMessage(message.jid, '*' + succ_on_bio + '*', MessageType.text)
            }
        }
        else if (match[1] == 'off') {
            if (bio_status !== 'true') {
                return await message.client.sendMessage(message.jid, '*' + alr_off_bio + '*', MessageType.text)
            }
            else {
                await heroku.patch(baseURI + '/config-vars', { 
                    body: { 
                        ['AUTO_Bƒ∞O']: 'false'
                    } 
                });
                await message.client.sendMessage(message.jid, '*' + succ_off_bio + '*', MessageType.text)
            }
        }
    }));

    DrkBot.addCommand({pattern: 'tts (.*)', fromMe: true, desc: Lang.TTS_DESC}, (async (message, match) => {

        if(match[1] === undefined || match[1] == "")
            return;
    
        let 
            LANG = config.LANG.toLowerCase(),
            ttsMessage = match[1],
            SPEED = 1.0

        if(langMatch = match[1].match("\\{([a-z]{2})\\}")) {
            LANG = langMatch[1]
            ttsMessage = ttsMessage.replace(langMatch[0], "")
        } 
        if(speedMatch = match[1].match("\\{([0].[0-9]+)\\}")) {
            SPEED = parseFloat(speedMatch[1])
            ttsMessage = ttsMessage.replace(speedMatch[0], "")
        }

        var buffer = await googleTTS.synthesize({
            text: ttsMessage,
            voice: LANG
        });
        await message.client.sendMessage(message.jid,buffer, MessageType.audio, {mimetype: Mimetype.mp4Audio, ptt: true});
    }));

    DrkBot.addCommand({pattern: 'song ?(.*)', fromMe: true, desc: Lang.SONG_DESC}, (async (message, match) => { 

        if (match[1] === '') return await message.client.sendMessage(message.jid,Lang.NEED_TEXT_SONG,MessageType.text);    
        let arama = await yts(match[1]);
        arama = arama.all;
        if(arama.length < 1) return await message.client.sendMessage(message.jid,Lang.NO_RESULT,MessageType.text);
        var reply = await message.client.sendMessage(message.jid,Lang.DOWNLOADING_SONG,MessageType.text);

        let title = arama[0].title.replace(' ', '+');
        let stream = ytdl(arama[0].videoId, {
            quality: 'highestaudio',
        });
    
        got.stream(arama[0].image).pipe(fs.createWriteStream(title + '.jpg'));
        ffmpeg(stream)
            .audioBitrate(320)
            .save('./' + title + '.mp3')
            .on('end', async () => {
                const writer = new ID3Writer(fs.readFileSync('./' + title + '.mp3'));
                writer.setFrame('TIT2', arama[0].title)
                    .setFrame('TPE1', [arama[0].author.name])
                    .setFrame('APIC', {
                        type: 3,
                        data: fs.readFileSync(title + '.jpg'),
                        description: arama[0].description
                    });
                writer.addTag();

                reply = await message.client.sendMessage(message.jid,Lang.UPLOADING_SONG,MessageType.text);
                await message.client.sendMessage(message.jid,Buffer.from(writer.arrayBuffer), MessageType.audio, {mimetype: Mimetype.mp4Audio, ptt: false});
            });
    }));

    DrkBot.addCommand({pattern: 'video ?(.*)', fromMe: true, desc: Lang.VIDEO_DESC}, (async (message, match) => { 

        if (match[1] === '') return await message.client.sendMessage(message.jid,Lang.NEED_VIDEO,MessageType.text);    
    
        var VID = '';
        try {
            if (match[1].includes('watch')) {
                var tsts = match[1].replace('watch?v=', '')
                var alal = tsts.split('/')[3]
                VID = alal
            } else {     
                VID = match[1].split('/')[3]
            }
        } catch {
            return await message.client.sendMessage(message.jid,Lang.NO_RESULT,MessageType.text);
        }
        var reply = await message.client.sendMessage(message.jid,Lang.DOWNLOADING_VIDEO,MessageType.text);

        var yt = ytdl(VID, {filter: format => format.container === 'mp4' && ['720p', '480p', '360p', '240p', '144p'].map(() => true)});
        yt.pipe(fs.createWriteStream('./' + VID + '.mp4'));

        yt.on('end', async () => {
            reply = await message.client.sendMessage(message.jid,Lang.UPLOADING_VIDEO,MessageType.text);
            await message.client.sendMessage(message.jid,fs.readFileSync('./' + VID + '.mp4'), MessageType.video, {mimetype: Mimetype.mp4});
        });
    }));

    DrkBot.addCommand({pattern: 'yt ?(.*)', fromMe: true, desc: Lang.YT_DESC}, (async (message, match) => { 

        if (match[1] === '') return await message.client.sendMessage(message.jid,Lang.NEED_WORDS,MessageType.text);    
        var reply = await message.client.sendMessage(message.jid,Lang.GETTING_VIDEOS,MessageType.text);

        try {
            var arama = await yts(match[1]);
        } catch {
            return await message.client.sendMessage(message.jid,Lang.NOT_FOUND,MessageType.text);
        }
    
        var mesaj = '';
        arama.all.map((video) => {
            mesaj += '*' + video.title + '* - ' + video.url + '\n'
        });

        await message.client.sendMessage(message.jid,mesaj,MessageType.text);
        await reply.delete();
    }));

    DrkBot.addCommand({pattern: 'wiki ?(.*)', fromMe: true, desc: Lang.WIKI_DESC}, (async (message, match) => { 

        if (match[1] === '') return await message.client.sendMessage(message.jid,Lang.NEED_WORDS,MessageType.text);    
        var reply = await message.client.sendMessage(message.jid,Lang.SEARCHING,MessageType.text);

        var arama = await wiki({ apiUrl: 'https://' + config.LANG + '.wikipedia.org/w/api.php' })
            .page(match[1]);

        var info = await arama.rawContent();
        await message.client.sendMessage(message.jid, info, MessageType.text);
        await reply.delete();
    }));

    DrkBot.addCommand({pattern: 'img ?(.*)', fromMe: true, desc: Lang.IMG_DESC}, (async (message, match) => { 

        if (match[1] === '') return await message.client.sendMessage(message.jid,Lang.NEED_WORDS,MessageType.text);
        gis(match[1], async (error, result) => {
            for (var i = 0; i < (result.length < 5 ? result.length : 5); i++) {
                var get = got(result[i].url, {https: {rejectUnauthorized: false}});
                var stream = get.buffer();
                
                stream.then(async (image) => {
                    await message.client.sendMessage(message.jid,image, MessageType.image);
                });
            }

            message.reply(Lang.IMG.format((result.length < 5 ? result.length : 5), match[1]));
        });
    }));
    
    DrkBot.addCommand({pattern: 'lyric ?(.*)', fromMe: true, desc: Slang.LY_DESC }, (async (message, match) => { 

        if (match[1] === '') return await message.client.sendMessage(message.jid, Slang.NEED, MessageType.text);

        var aut = await solenolyrics.requestLyricsFor(`${match[1]}`); 
        var son = await solenolyrics.requestAuthorFor(`${match[1]}`);
        var cov = await solenolyrics.requestIconFor(`${match[1]}`);
        var tit = await solenolyrics.requestTitleFor(`${match[1]}`);

        var buffer = await axios.get(cov, {responseType: 'arraybuffer'});

        await message.client.sendMessage(message.jid, Buffer.from(buffer.data),  MessageType.image, {caption: `*${Slang.ARAT}* ` + '```' + `${match[1]}` + '```' + `\n*${Slang.BUL}* ` + '```' + tit + '```' + `\n*${Slang.AUT}* ` + '```' + son + '```' + `\n*${Slang.SLY}*\n\n` + aut });

    }));
// fin duplicado ===========================================================================
}
